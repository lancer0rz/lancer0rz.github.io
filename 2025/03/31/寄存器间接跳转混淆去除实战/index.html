<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="baidu-site-verification" content="codeva-OBVxxxxx" />
    <meta name="msvalidate.01" content="B9019CE3751A15D6xxxxxxxxxxxxxxxx" />
    <meta name="description" content="寄存器间接跳转的基本概念寄存器存储地址：寄存器间接跳转依赖于寄存器内的值来指定要跳转到的地址，而这个地址可以在程序运行时动态改变。跳转指令：在汇编语言中，类似于 jmp eax 或 br x8 的指令，使用寄存器（如 eax, x8 等）存储目标地址，执行这些指令后，程序的控制流就会转移到寄存器中的指定地址。作为混淆，这种基于寄存器间接跳转的混淆会使反编译器无法正常识别代码逻辑那么为了能够看清程序">
<meta property="og:type" content="article">
<meta property="og:title" content="寄存器间接跳转混淆去除实战">
<meta property="og:url" content="https://lancer0rz.github.io/2025/03/31/%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E8%B7%B3%E8%BD%AC%E6%B7%B7%E6%B7%86%E5%8E%BB%E9%99%A4%E5%AE%9E%E6%88%98/index.html">
<meta property="og:site_name" content="l4n&#39;s blog">
<meta property="og:description" content="寄存器间接跳转的基本概念寄存器存储地址：寄存器间接跳转依赖于寄存器内的值来指定要跳转到的地址，而这个地址可以在程序运行时动态改变。跳转指令：在汇编语言中，类似于 jmp eax 或 br x8 的指令，使用寄存器（如 eax, x8 等）存储目标地址，执行这些指令后，程序的控制流就会转移到寄存器中的指定地址。作为混淆，这种基于寄存器间接跳转的混淆会使反编译器无法正常识别代码逻辑那么为了能够看清程序">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-03-31T10:11:06.000Z">
<meta property="article:modified_time" content="2025-03-31T15:32:56.659Z">
<meta property="article:author" content="l4n">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/avatar.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/avatar.jpg" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpg">
        
      
    
    <!-- title -->
    <title>寄存器间接跳转混淆去除实战</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 7.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="modal" class="modal">
  <span id="modal_close_btn" class="modal-close-btn">x</span>
  <img id="modal_image" class="modal-image">
  <!-- <div id="caption"></div> -->
</div>

      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/Friends/">Friends</a></li><!--
     --><!--
       --><li><a href="/Search/">Search</a></li><!--
     --><!--
       --><li><a href="/About/">About</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2025/07/23/wsl-ubuntu-%E4%B8%AA%E4%BA%BA%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <!-- <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://lancer0rz.github.io/2025/03/31/%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E8%B7%B3%E8%BD%AC%E6%B7%B7%E6%B7%86%E5%8E%BB%E9%99%A4%E5%AE%9E%E6%88%98/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li> -->
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://lancer0rz.github.io/2025/03/31/%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E8%B7%B3%E8%BD%AC%E6%B7%B7%E6%B7%86%E5%8E%BB%E9%99%A4%E5%AE%9E%E6%88%98/&text=寄存器间接跳转混淆去除实战"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <!-- <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://lancer0rz.github.io/2025/03/31/%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E8%B7%B3%E8%BD%AC%E6%B7%B7%E6%B7%86%E5%8E%BB%E9%99%A4%E5%AE%9E%E6%88%98/&title=寄存器间接跳转混淆去除实战"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li> -->
  <!-- <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://lancer0rz.github.io/2025/03/31/%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E8%B7%B3%E8%BD%AC%E6%B7%B7%E6%B7%86%E5%8E%BB%E9%99%A4%E5%AE%9E%E6%88%98/&is_video=false&description=寄存器间接跳转混淆去除实战"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li> -->
  <li><a class="icon" href="mailto:?subject=寄存器间接跳转混淆去除实战&body=Check out this article: https://lancer0rz.github.io/2025/03/31/%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E8%B7%B3%E8%BD%AC%E6%B7%B7%E6%B7%86%E5%8E%BB%E9%99%A4%E5%AE%9E%E6%88%98/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://lancer0rz.github.io/2025/03/31/%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E8%B7%B3%E8%BD%AC%E6%B7%B7%E6%B7%86%E5%8E%BB%E9%99%A4%E5%AE%9E%E6%88%98/&title=寄存器间接跳转混淆去除实战"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <!-- <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://lancer0rz.github.io/2025/03/31/%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E8%B7%B3%E8%BD%AC%E6%B7%B7%E6%B7%86%E5%8E%BB%E9%99%A4%E5%AE%9E%E6%88%98/&title=寄存器间接跳转混淆去除实战"><i class="fab fa-reddit " aria-hidden="true"></i></a></li> -->
  <!-- <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://lancer0rz.github.io/2025/03/31/%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E8%B7%B3%E8%BD%AC%E6%B7%B7%E6%B7%86%E5%8E%BB%E9%99%A4%E5%AE%9E%E6%88%98/&title=寄存器间接跳转混淆去除实战"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li> -->
  <!-- <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://lancer0rz.github.io/2025/03/31/%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E8%B7%B3%E8%BD%AC%E6%B7%B7%E6%B7%86%E5%8E%BB%E9%99%A4%E5%AE%9E%E6%88%98/&title=寄存器间接跳转混淆去除实战"><i class="fab fa-digg " aria-hidden="true"></i></a></li> -->
  <!-- <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://lancer0rz.github.io/2025/03/31/%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E8%B7%B3%E8%BD%AC%E6%B7%B7%E6%B7%86%E5%8E%BB%E9%99%A4%E5%AE%9E%E6%88%98/&name=寄存器间接跳转混淆去除实战&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li> -->
  <!-- <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://lancer0rz.github.io/2025/03/31/%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E8%B7%B3%E8%BD%AC%E6%B7%B7%E6%B7%86%E5%8E%BB%E9%99%A4%E5%AE%9E%E6%88%98/&t=寄存器间接跳转混淆去除实战"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li> -->
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E8%B7%B3%E8%BD%AC%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">寄存器间接跳转的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%84%E7%90%86%E6%80%9D%E8%B7%AF"><span class="toc-number">2.</span> <span class="toc-text">简单的处理思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E4%B8%80%E7%82%B9%E7%9A%84%E8%BF%9B%E9%98%B6%E6%80%9D%E8%B7%AF"><span class="toc-number">3.</span> <span class="toc-text">自动化一点的进阶思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%EF%BC%9AN1CTF-junior-easy-re"><span class="toc-number">3.1.</span> <span class="toc-text">实例：N1CTF junior easy-re</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#step1-%E6%8C%89%E7%85%A7%E4%B8%8D%E5%90%8C%E8%B7%B3%E8%BD%AC%E5%88%86%E6%94%AF%E8%BF%9B%E8%A1%8C%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86"><span class="toc-number">4.</span> <span class="toc-text">step1 按照不同跳转分支进行信息搜集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#step2-%E6%A8%A1%E6%8B%9F%E6%89%A7%E8%A1%8C%EF%BC%8C%E8%8E%B7%E5%8F%96%E6%9C%80%E7%BB%88%E8%B7%B3%E8%BD%AC%E5%80%BC"><span class="toc-number">5.</span> <span class="toc-text">step2 模拟执行，获取最终跳转值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#step3-%E4%BD%BF%E7%94%A8%E4%B8%8A%E4%B8%80%E6%AD%A5%E7%9A%84%E5%80%BC%E8%BF%9B%E8%A1%8CPatch"><span class="toc-number">6.</span> <span class="toc-text">step3 使用上一步的值进行Patch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Final%EF%BC%9A%E5%AE%8C%E6%95%B4%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81"><span class="toc-number">7.</span> <span class="toc-text">Final：完整实现代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number">8.</span> <span class="toc-text">参考链接</span></a></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        寄存器间接跳转混淆去除实战
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">l4n</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2025-03-31T10:11:06.000Z" class="dt-published" itemprop="datePublished">2025-03-31</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h2 id="寄存器间接跳转的基本概念"><a href="#寄存器间接跳转的基本概念" class="headerlink" title="寄存器间接跳转的基本概念"></a>寄存器间接跳转的基本概念</h2><p>寄存器存储地址：寄存器间接跳转依赖于寄存器内的值来指定要跳转到的地址，而这个地址可以在程序运行时动态改变。<br>跳转指令：在汇编语言中，类似于 jmp eax 或 br x8 的指令，使用寄存器（如 eax, x8 等）存储目标地址，执行这些指令后，程序的控制流就会转移到寄存器中的指定地址。<br>作为混淆，这种基于寄存器间接跳转的混淆会使反编译器无法正常识别代码逻辑<br>那么为了能够看清程序的逻辑，我们需要对这玩意进行修复。</p>
<h2 id="简单的处理思路"><a href="#简单的处理思路" class="headerlink" title="简单的处理思路"></a>简单的处理思路</h2><p>大部分的间接跳转将用于计算地址的值储存在data段，而反编译器不会去解析data段的常量。这是因为在反编译器的预设中，data段是默认可写的。这时被引用的值被视为变量，就不会进行常量传播优化。<br>如果我们将data段的属性改为只读，可以促进反编译器的常量传播，去除一部分混淆。</p>
<h2 id="自动化一点的进阶思路"><a href="#自动化一点的进阶思路" class="headerlink" title="自动化一点的进阶思路"></a>自动化一点的进阶思路</h2><p>一个比较常规的思路是用模拟执行框架来解出跳转时对应寄存器存储的具体值，然后进行patch去除。这里我选择了使用unicorn，当然 angr&#x2F;qiling等框架应该也是可以的，只是作为初学者我不太会写，还是unicorn写着顺手。</p>
<h3 id="实例：N1CTF-junior-easy-re"><a href="#实例：N1CTF-junior-easy-re" class="headerlink" title="实例：N1CTF junior easy-re"></a>实例：N1CTF junior easy-re</h3><p>是一个arm64的elf，有间接跳转和字符串混淆。字符串混淆可以通过unicorn 内存写入trace简单的过掉。这里只讨论如何去除间接跳转混淆。<br>一个具体的汇编代码片段例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">loc_1E60                                ; CODE XREF: sub_1FD4+2C↓j</span><br><span class="line">LDR             W8, [SP,#0x1C0+var_140] ; Load from Memory</span><br><span class="line">MOV             W9, #2                  ; Rd = Op2</span><br><span class="line">MOV             W10, #0                 ; Rd = Op2</span><br><span class="line">CMP             W8, #0x100              ; Set cond. codes on Op1 - Op2</span><br><span class="line">CSEL            W8, W9, W10, LT         ; Conditional Select</span><br><span class="line">MOV             W11, W8                 ; Rd = Op2</span><br><span class="line">SXTW            X11, W11                ; Signed Extend Word</span><br><span class="line">MOV             X12, #8                 ; Rd = Op2</span><br><span class="line">MUL             X11, X12, X11           ; Multiply</span><br><span class="line">LDR             X12, [SP,#0x1C0+var_190] ; Load from Memory</span><br><span class="line">ADD             X11, X12, X11           ; Rd = Op1 + Op2</span><br><span class="line">LDR             X11, [X11]              ; Load from Memory</span><br><span class="line">MOV             W8, #0x464CA149</span><br><span class="line">LDR             W9, [SP,#0x1C0+var_19C] ; Load from Memory</span><br><span class="line">SUBS            W8, W8, W9              ; Rd = Op1 - Op2</span><br><span class="line">MOV             W13, W8                 ; Rd = Op2</span><br><span class="line">SXTW            X13, W13                ; Signed Extend Word</span><br><span class="line">ADD             X11, X11, X13           ; Rd = Op1 + Op2</span><br><span class="line">BR              X11                     ; Branch To Register</span><br></pre></td></tr></table></figure>

<p>可以发现很明显的特征代码块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov x1 #x</span><br><span class="line">mov x2 #x</span><br><span class="line">...</span><br><span class="line">cslr xx x1 x2 eq </span><br><span class="line">...</span><br><span class="line">br xx</span><br></pre></td></tr></table></figure>

<p>基于这样的特征，我们可以在初始化的时候，使用模式匹配遍历.text .initarray等代码段。然后将mov的地址，br的地址（cslr地址）存入一个要去执行的list里。在遍历完后，循环分别处理每一段地址作为参数传入模拟执行函数。</p>
<p>假设我们已经识别了所有的指令，现在要做的就是如何去除。<br>如果优化掉后面的查表计算等操作，将前面的值分别确定，模拟执行拿到数据后，就可以直接patch成正常的跳转，自然可以被正常的反编译。<br>于是我们的思路有了，具体拆成以下几个部分来分别实现。</p>
<ol>
<li>patch cslr 为 mov xx1&#x2F;mov xx2 </li>
<li>依据不明确取值的寄存器，向上溯回拿到值，模拟执行后拿到后续br的值</li>
<li>patch掉 mov下标 cslr 查表 计算地址 brxx</li>
<li>cmp xx后，逻辑patch为 b xx1 和 b xx2</li>
</ol>
<p>一步一步完成吧。</p>
<h2 id="step1-按照不同跳转分支进行信息搜集"><a href="#step1-按照不同跳转分支进行信息搜集" class="headerlink" title="step1 按照不同跳转分支进行信息搜集"></a>step1 按照不同跳转分支进行信息搜集</h2><p>先拿到cslr指令和操作数，然后依据对应的操作数，拿到mov指令的形状后，patch，分为两个分支模拟执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">saved_state = &#123;&#125;</span><br><span class="line">def save_state(mu):</span><br><span class="line">    regs = &#123;&#125;</span><br><span class="line">    regs_list = [</span><br><span class="line">        UC_ARM64_REG_X0, UC_ARM64_REG_X1, UC_ARM64_REG_X2, UC_ARM64_REG_X3,</span><br><span class="line">        UC_ARM64_REG_X4, UC_ARM64_REG_X5, UC_ARM64_REG_X6, UC_ARM64_REG_X7,</span><br><span class="line">        UC_ARM64_REG_X8, UC_ARM64_REG_X9, UC_ARM64_REG_X10, UC_ARM64_REG_X11,</span><br><span class="line">        UC_ARM64_REG_X12, UC_ARM64_REG_X13, UC_ARM64_REG_X14, UC_ARM64_REG_X15,</span><br><span class="line">        UC_ARM64_REG_X16, UC_ARM64_REG_X17, UC_ARM64_REG_X18, UC_ARM64_REG_X19,</span><br><span class="line">        UC_ARM64_REG_X20, UC_ARM64_REG_X21, UC_ARM64_REG_X22, UC_ARM64_REG_X23,</span><br><span class="line">        UC_ARM64_REG_X24, UC_ARM64_REG_X25, UC_ARM64_REG_X26, UC_ARM64_REG_X27,</span><br><span class="line">        UC_ARM64_REG_X28, UC_ARM64_REG_X29, UC_ARM64_REG_X30, UC_ARM64_REG_SP,</span><br><span class="line">        UC_ARM64_REG_PC</span><br><span class="line">    ]</span><br><span class="line">    for reg in regs_list:</span><br><span class="line">        regs[reg] = mu.reg_read(reg)</span><br><span class="line">    return regs</span><br><span class="line"></span><br><span class="line">def restore_state(mu, regs):</span><br><span class="line">    for reg, val in regs.items():</span><br><span class="line">        mu.reg_write(reg, val)</span><br><span class="line"></span><br><span class="line">def branch_hook(mu, addr, size, user_data):</span><br><span class="line">    # 对当前指令反汇编，若遇到BR指令则终止模拟</span><br><span class="line">    for inst in cs.disasm(mu.mem_read(addr, size), addr):</span><br><span class="line">        if inst.mnemonic.lower() == &quot;br&quot;:</span><br><span class="line">            print(&quot;&gt;&gt;&gt; BR 指令在 0x%x 被触发，停止模拟&quot; % addr)</span><br><span class="line">            mu.emu_stop()</span><br><span class="line">            break</span><br><span class="line">    return </span><br><span class="line"></span><br><span class="line">pass_addr = [0x24A8,0x24AC,0x1E20]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">csel_handled = False</span><br><span class="line">def hook_code(mu, address, size, user_data): </span><br><span class="line">    global save_state , csel_handled</span><br><span class="line">    if address in LIBC_FUNCS:</span><br><span class="line">        print(&quot;&gt;&gt;&gt; Entering simulated library function at 0x%x&quot; % address)</span><br><span class="line">        LIBC_FUNCS[address](mu)</span><br><span class="line">        return</span><br><span class="line">    </span><br><span class="line">    # if address in pass_addr:# 修改类似eip的寄存器来跳过这两个地址</span><br><span class="line">    #     mu.reg_write(UC_ARM64_REG_PC, address+size)</span><br><span class="line">    #     print(&#x27;&gt;&gt;&gt; Skipping address 0x%x&#x27; % address)</span><br><span class="line">    </span><br><span class="line">    # print(&#x27;&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x&#x27; % (address, size))</span><br><span class="line">    # 打印汇编代码</span><br><span class="line">    for inst in cs.disasm(mu.mem_read(address, size), address):</span><br><span class="line">        print(&quot;0x%x:\t%s\t%s&quot; % (inst.address, inst.mnemonic, inst.op_str))</span><br><span class="line">        #如果当前指令是CSEL</span><br><span class="line">        if inst.mnemonic.lower() == &quot;csel&quot; and not csel_handled:</span><br><span class="line">            print(&quot;&gt;&gt;&gt; csel detected&quot;)</span><br><span class="line">            csel_handled = True</span><br><span class="line">            csel_addr = address</span><br><span class="line">            original_bytes = mu.mem_read(csel_addr, size)</span><br><span class="line">            saved_state = save_state(mu)#保存当前状态</span><br><span class="line">            #获取操作寄存器</span><br><span class="line">            op = inst.op_str.split(&quot;, &quot;)</span><br><span class="line">            #组装mov指令</span><br><span class="line">            mov_inst1 = &quot;mov &quot; + op[0] + &quot;, &quot; + op[1] +&#x27;;&#x27;</span><br><span class="line">            mov_inst2 = &quot;mov &quot; + op[0] + &quot;, &quot; + op[2] +&#x27;;&#x27;</span><br><span class="line">            # print(&#x27;&gt;&gt;&gt; mov instructions:&#x27;, mov_inst1, mov_inst2)</span><br><span class="line">            #编译mov指令</span><br><span class="line">            asm_mov_x1_x2, _ = ks.asm(mov_inst1)</span><br><span class="line">            asm_mov_x1_x3, _ = ks.asm(mov_inst2)</span><br><span class="line">            # print(&#x27;there&#x27;)</span><br><span class="line">            #定义内部函数，用于进行两次patch</span><br><span class="line">            def run_branch_test(patch_bytes, branch_label):</span><br><span class="line">                # patch 当前 csel 指令位置</span><br><span class="line">                mu.mem_write(csel_addr, bytes(patch_bytes))</span><br><span class="line">                print(f&quot;&gt;&gt;&gt; 已将 csel 指令 patch 为 &#123;branch_label&#125;，开始执行至遇到 BR 指令&quot;)</span><br><span class="line">                # 添加一个临时 hook 来检测 BR 指令</span><br><span class="line">                bh_id = mu.hook_add(UC_HOOK_CODE, branch_hook)</span><br><span class="line">                try:</span><br><span class="line">                    mu.emu_start(mu.reg_read(UC_ARM64_REG_PC), END_POINT)</span><br><span class="line">                except UcError as e:</span><br><span class="line">                    print(&quot;模拟过程中出现错误:&quot;, e)</span><br><span class="line">                mu.hook_del(bh_id)</span><br><span class="line">                state = save_state(mu)</span><br><span class="line">                print(&quot;&gt;&gt;&gt; 运行结束后状态:&quot;, state)</span><br><span class="line">                return state</span><br><span class="line">            </span><br><span class="line">            # 首先用 mov x1, x2 运行</span><br><span class="line">            state_branch1 = run_branch_test(asm_mov_x1_x2, &quot;mov x1, x2&quot;)</span><br><span class="line">            # 恢复现场</span><br><span class="line">            restore_state(mu, saved_state)</span><br><span class="line">            # 然后用 mov x1, x3 运行</span><br><span class="line">            state_branch2 = run_branch_test(asm_mov_x1_x3, &quot;mov x1, x3&quot;)</span><br><span class="line">            print(&quot;&gt;&gt;&gt; 分别 patch 后两条分支的最终状态:&quot;)</span><br><span class="line">            print(&quot;    mov x1, x2 状态:&quot;, hex(state_branch1[UC_ARM64_REG_X8]))</span><br><span class="line">            print(&quot;    mov x1, x3 状态:&quot;, hex(state_branch2[UC_ARM64_REG_X8]))</span><br><span class="line">            </span><br></pre></td></tr></table></figure>

<h2 id="step2-模拟执行，获取最终跳转值"><a href="#step2-模拟执行，获取最终跳转值" class="headerlink" title="step2 模拟执行，获取最终跳转值"></a>step2 模拟执行，获取最终跳转值</h2><p>已经有了模拟执行的框架，这里就直接写一个方法去拿到相关的指令储存起来</p>
<p>那么有小伙伴就要问了，如何拿到相关的指令呢？这里其实可以注意到，这段混淆实际上是通过先取立即数和地址，然后存入栈，在后续重新从栈上拿回地址。所以我们可以在范围内遍历有关sp的指令，然后确定偏移，向上溯回，找到所有对改位置进行写入的寄存器。通过跟踪这些寄存器，我们就能拿到相应的赋值指令，进而在后续模拟执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">def hit_hook(self, mu: Uc, addr: int, size: int, user_data) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        代码 hook，用于捕获并存储 hit 指令（通过向上追踪含 SP 且 ldr 指令）。</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        </span><br><span class="line">        try:</span><br><span class="line">            code = mu.mem_read(addr, size)</span><br><span class="line">        except UcError:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        for inst in self.cs.disasm(code, addr):</span><br><span class="line">            # print(f&quot;hit hook : &gt;&gt;&gt; &#123;hex(addr)&#125; &#123;inst.mnemonic&#125; &#123;inst.op_str&#125;&quot;)</span><br><span class="line">            if inst.mnemonic.lower() == &quot;br&quot;:</span><br><span class="line">                mu.emu_stop()</span><br><span class="line">                break</span><br><span class="line">            if inst.mnemonic.lower() == &quot;stur&quot; or inst.mnemonic.lower() == &quot;ldur&quot;:</span><br><span class="line">                self.mu.reg_write(UC_ARM64_REG_PC, addr + size)</span><br><span class="line">                # print(f&quot;&gt;&gt;&gt; stur or ldur detected, skip&quot;)</span><br><span class="line">                return</span><br><span class="line">            if &quot;sp&quot; in inst.op_str and &quot;ldr&quot; in inst.mnemonic:</span><br><span class="line">                # print(f&quot;attached ldr sp instruction: &#123;inst.mnemonic&#125; &#123;inst.op_str&#125;&quot;)</span><br><span class="line">                parts = inst.op_str.split(&quot;, [&quot;)</span><br><span class="line">                target = parts[0] if &quot;sp&quot; in parts[0] else parts[1]</span><br><span class="line">                target_state = False</span><br><span class="line">                target2 = &quot;&quot;</span><br><span class="line">                curr_addr = addr</span><br><span class="line">                for _ in range(1, 200):</span><br><span class="line">                    curr_addr -= inst.size</span><br><span class="line">                    try:</span><br><span class="line">                        code_b = mu.mem_read(curr_addr, 4)</span><br><span class="line">                    except UcError:</span><br><span class="line">                        continue</span><br><span class="line">                    for inst_b in self.cs.disasm(code_b, curr_addr):</span><br><span class="line">                        if target in inst_b.op_str and &quot;ldr&quot; not in inst_b.mnemonic and not target_state:</span><br><span class="line">                            # print(f&quot;hit instruction: &#123;inst_b.mnemonic&#125; &#123;inst_b.op_str&#125;&quot;)</span><br><span class="line">                            target_state = True</span><br><span class="line">                            self.hit_inst.append(inst_b)</span><br><span class="line">                            parts_b = inst_b.op_str.split(&quot;, &quot;)</span><br><span class="line">                            target2 = parts_b[0] if target not in parts_b[0] else parts_b[1]</span><br><span class="line">                            break</span><br><span class="line">                        if target_state and target2 in inst_b.op_str and &quot;mov&quot; in inst_b.mnemonic and &#x27;#0x&#x27; in inst_b.op_str:</span><br><span class="line">                            self.hit_inst.append(inst_b)</span><br><span class="line">                        if target_state and target2 in inst_b.op_str and &#x27;adr&#x27; in inst_b.mnemonic:</span><br><span class="line">                            # print(f&quot;hit instruction: &#123;inst_b.mnemonic&#125; &#123;inst_b.op_str&#125;&quot;)</span><br><span class="line">                            if &quot;adrp&quot; in inst_b.mnemonic:</span><br><span class="line">                                try:</span><br><span class="line">                                    next_code = mu.mem_read(curr_addr + inst_b.size, 4)</span><br><span class="line">                                except UcError:</span><br><span class="line">                                    continue</span><br><span class="line">                                for inst_el in self.cs.disasm(next_code, curr_addr + inst_b.size):</span><br><span class="line">                                    if &quot;add&quot; in inst_el.mnemonic:</span><br><span class="line">                                        self.hit_inst.append(inst_el)</span><br><span class="line">                                        self.hit_inst.append(inst_b)</span><br><span class="line">                            else:</span><br><span class="line">                                self.hit_inst.append(inst_b)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    def branch_hook(self, mu: Uc, addr: int, size: int, user_data) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        当执行到 BR 指令时停止模拟</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        try:</span><br><span class="line">            code = mu.mem_read(addr, size)</span><br><span class="line">        except UcError:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        for inst in self.cs.disasm(code, addr):</span><br><span class="line">            if inst.mnemonic.lower() == &quot;br&quot;:</span><br><span class="line">                # print(f&quot;&gt;&gt;&gt; BR 指令在 0x&#123;addr:x&#125; 被触发，停止模拟&quot;)</span><br><span class="line">                mu.emu_stop()</span><br><span class="line">                break</span><br><span class="line">    </span><br><span class="line">    def get_hit_inst(self, addr: int) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        从指定地址向后模拟收集 hit 指令</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # print(f&quot;&gt;&gt;&gt; Getting hit instructions from 0x&#123;addr:x&#125; to 0x&#123;self.inst_br_addr_temp:x&#125;&quot;)</span><br><span class="line">        bh_id = self.mu.hook_add(UC_HOOK_CODE, self.hit_hook)</span><br><span class="line">        self.mu.hook_del(self.hook_code_id)</span><br><span class="line">        # 搜寻前面的有没有立即数存储指令</span><br><span class="line">        for i in range(1, 50):</span><br><span class="line">            try:</span><br><span class="line">                code = self.mu.mem_read(addr - i * 4, 4)</span><br><span class="line">            except UcError:</span><br><span class="line">                continue</span><br><span class="line">            for inst in self.cs.disasm(code, addr - i * 4):</span><br><span class="line">                # print(f&quot;get_hit_inst : &gt;&gt;&gt; &#123;hex(addr - i * 4)&#125; &#123;inst.mnemonic&#125; &#123;inst.op_str&#125;&quot;)</span><br><span class="line">                if (&quot;mov&quot; in inst.mnemonic or &quot;ldr&quot; in inst.mnemonic ) and &#x27;#&#x27; in inst.op_str:</span><br><span class="line">                    self.hit_inst.append(inst)</span><br><span class="line">        </span><br><span class="line">        try:</span><br><span class="line">            self.mu.emu_start(addr - 4, self.inst_br_addr_temp)</span><br><span class="line">        except UcError as e:</span><br><span class="line">            print(&quot;模拟过程中出现错误:&quot;, e)</span><br><span class="line">            self.err_flag = True</span><br><span class="line">            self.err_addr.append((self.inst_mov_addr_temp, self.inst_br_addr_temp,&quot;error at get_hit_inst:&quot;, e))</span><br><span class="line">        self.mu.hook_del(bh_id)</span><br><span class="line">        self.hook_code_id = self.mu.hook_add(UC_HOOK_CODE, self.hook_code)</span><br><span class="line">        # print(&quot;\n&gt;&gt;&gt; Hit instructions:&quot;)</span><br><span class="line">        # for inst in self.hit_inst:</span><br><span class="line">        #     print(f&quot;    0x&#123;inst.address:x&#125;: &#123;inst.mnemonic&#125; &#123;inst.op_str&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    def run_hit_inst(self) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        只模拟 hit 指令（hit_inst 列表中的指令）。</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # print(&quot;&gt;&gt;&gt; Running hit instructions&quot;)</span><br><span class="line">        original_pc = self.mu.reg_read(UC_ARM64_REG_PC)</span><br><span class="line">        for inst in reversed(self.hit_inst):</span><br><span class="line">            </span><br><span class="line">            try:</span><br><span class="line">                self.mu.emu_start(inst.address, inst.address + inst.size)</span><br><span class="line">            except UcError as e:</span><br><span class="line">                print(&quot;run_hit_inst 模拟出现错误:&quot;, e)</span><br><span class="line">                self.err_flag = True</span><br><span class="line">                self.err_addr.append((self.inst_mov_addr_temp, self.inst_br_addr_temp, &quot;error at run_hit_inst:&quot;, e))</span><br><span class="line">        self.mu.reg_write(UC_ARM64_REG_PC, original_pc)</span><br></pre></td></tr></table></figure>

<p>在unicorn加载的时候，没有load .data段到正确的地方，导致在.data段上的值无法被正确的读取。我们可以使用lief对文件进行解析，分别计算出对应section的虚拟地址和正确的patch地址，然后代替直接将整个文件加载，把对应的段分别正确的映射到unicorn的虚拟内存里。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">        利用 LIEF 解析 ELF 文件，将各 section 映射到 Unicorn 内存中。</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        binary = lief.parse(self.binary_path)</span><br><span class="line">        mapped = &#123;&#125;  # 已映射区域字典</span><br><span class="line"></span><br><span class="line">        for section in binary.sections:</span><br><span class="line">            vaddr = section.virtual_address</span><br><span class="line">            mem_size = section.size</span><br><span class="line">            if mem_size == 0 or vaddr == 0:</span><br><span class="line">                continue</span><br><span class="line">            if section.name == &quot;.text&quot;:</span><br><span class="line">                self.text_section = section</span><br><span class="line">            start_addr = (vaddr // self.PAGE_SIZE) * self.PAGE_SIZE</span><br><span class="line">            end_addr = ((vaddr + mem_size + self.PAGE_SIZE - 1) // self.PAGE_SIZE) * self.PAGE_SIZE</span><br><span class="line">            map_size = end_addr - start_addr</span><br><span class="line"></span><br><span class="line">            if start_addr not in mapped:</span><br><span class="line">                try:</span><br><span class="line">                    self.mu.mem_map(start_addr, map_size)</span><br><span class="line">                    mapped[start_addr] = map_size</span><br><span class="line">                except UcError as e:</span><br><span class="line">                    print(f&quot;映射地址&#123;section.name&#125; 0x&#123;start_addr:x&#125;（大小 0x&#123;map_size:x&#125;）失败: &#123;e&#125;&quot;)</span><br><span class="line">                    continue</span><br><span class="line"></span><br><span class="line">            if section.content:</span><br><span class="line">                data = bytes(section.content)</span><br><span class="line">                offset = vaddr - start_addr</span><br><span class="line">                try:</span><br><span class="line">                    self.mu.mem_write(start_addr + offset, data)</span><br><span class="line">                except UcError as e:</span><br><span class="line">                    print(f&quot;写入数据到地址 0x&#123;start_addr+offset:x&#125; 失败: &#123;e&#125;&quot;)</span><br></pre></td></tr></table></figure>

<p>跑一下发现，虽然有几个段没有成功映射，但大部分段都成功的加载了。</p>
<h2 id="step3-使用上一步的值进行Patch"><a href="#step3-使用上一步的值进行Patch" class="headerlink" title="step3 使用上一步的值进行Patch"></a>step3 使用上一步的值进行Patch</h2><p>获取了正确的跳转地址后，我们就可以想想如何去patch逻辑了。<br>再看看代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">loc_1E60                                ; CODE XREF: sub_1FD4+2C↓j</span><br><span class="line">LDR             W8, [SP,#0x1C0+var_140] ; Load from Memory</span><br><span class="line">MOV             W9, #2                  ; Rd = Op2</span><br><span class="line">MOV             W10, #0                 ; Rd = Op2</span><br><span class="line">CMP             W8, #0x100              ; Set cond. codes on Op1 - Op2</span><br><span class="line">CSEL            W8, W9, W10, LT         ; Conditional Select</span><br><span class="line">MOV             W11, W8                 ; Rd = Op2</span><br><span class="line">SXTW            X11, W11                ; Signed Extend Word</span><br><span class="line">MOV             X12, #8                 ; Rd = Op2</span><br><span class="line">MUL             X11, X12, X11           ; Multiply</span><br><span class="line">LDR             X12, [SP,#0x1C0+var_190] ; Load from Memory</span><br><span class="line">ADD             X11, X12, X11           ; Rd = Op1 + Op2</span><br><span class="line">LDR             X11, [X11]              ; Load from Memory</span><br><span class="line">MOV             W8, #0x464CA149</span><br><span class="line">LDR             W9, [SP,#0x1C0+var_19C] ; Load from Memory</span><br><span class="line">SUBS            W8, W8, W9              ; Rd = Op1 - Op2</span><br><span class="line">MOV             W13, W8                 ; Rd = Op2</span><br><span class="line">SXTW            X13, W13                ; Signed Extend Word</span><br><span class="line">ADD             X11, X11, X13           ; Rd = Op1 + Op2</span><br><span class="line">BR              X11                     ; Branch To Register</span><br></pre></td></tr></table></figure>

<p>cslr之后，所有的计算基本都是对最终br的寄存器进行地址计算，而事实上我们已经有了这些值，就不需要再进行这些计算了。<br>先设计一下应该执行的指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MOV             W9, #2                  ; Rd = Op2</span><br><span class="line">MOV             W10, #0                 ; Rd = Op2</span><br><span class="line">CMP             W8, #0x100              ; Set cond. codes on Op1 - Op2</span><br><span class="line">CSEL            W8, W9, W10, LT         ; Conditional Select</span><br><span class="line">...</span><br><span class="line">cmp             w8, w9            </span><br><span class="line">beq             addr1 ; 等于就跳转，即第一种情况                  </span><br><span class="line">bne             addr2   ; 不等就跳转，即第二种情况          </span><br><span class="line">...</span><br><span class="line">BR              reg    ; patch到这里</span><br></pre></td></tr></table></figure>

<p>注意到，CMP后的指令顺序是不变的，而且cmp的结果就决定了后续跳转的地址。所以我们可以拿下面的固定不变指令来做一点文章。<br>如果我们设计为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nop &lt; mov x1 #r</span><br><span class="line">nop &lt; mov x2 #i</span><br><span class="line">...</span><br><span class="line">cmp   xx #0</span><br><span class="line">br.ne addr1</span><br><span class="line">br    addr2</span><br><span class="line">nop</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>就可以完成这些工作。但是有一个问题是，如果过早jmp，br后面的代码对于之后程序的执行可能会有一定影响。<br>所以我们要进行指令前移，在所有其余指令执行完后，再进行br操作。<br>如何实现指令前移呢？观察代码。在一些混淆中，br之前做了一些常量保存工作，如果贸然nop掉会导致后续指令无法执行。<br>所以我们可以采取这样的做法</p>
<ol>
<li>遍历cslr到br间的所有指令，取出str指令</li>
<li>将str指令上移</li>
<li>patch跳转指令，然后nop掉剩余的所有指令</li>
</ol>
<p>代码实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">def patch_br(self) -&gt; None:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">        扫描 self.csel_addr_temp 到 self.inst_br_addr_temp 区间内的所有指令，</span><br><span class="line">        记录所有 STR 指令，将所有 STR 指令上移，其余指令下移，</span><br><span class="line">        重新构造新的指令序列：首先放置所有 STR 指令，</span><br><span class="line">        然后是两条分支指令，</span><br><span class="line">        剩余空间填充 NOP 指令，</span><br><span class="line">        最后将组装好的字节补丁写入内存。</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    all_insts = []   # 保存区间内所有(地址, 指令)元组</span><br><span class="line">    str_insts = []   # 保存STR类型指令</span><br><span class="line"></span><br><span class="line">    addr_start = self.csel_addr_temp </span><br><span class="line">    for addr in range(addr_start, self.inst_br_addr_temp, 4):</span><br><span class="line">        try:</span><br><span class="line">            code = self.mu.mem_read(addr, 4)</span><br><span class="line">        except UcError:</span><br><span class="line">            continue</span><br><span class="line">            for inst in self.cs.disasm(code, addr):</span><br><span class="line">                all_insts.append((addr, inst))</span><br><span class="line">                if &quot;str&quot; in inst.mnemonic.lower():</span><br><span class="line">                    str_insts.append((addr, inst))</span><br><span class="line"></span><br><span class="line">        print(&quot;&gt;&gt;&gt; 扫描到的所有指令:&quot;)</span><br><span class="line">    for addr, inst in all_insts:</span><br><span class="line">        print(f&quot;    0x&#123;addr:x&#125;: &#123;inst.mnemonic&#125; &#123;inst.op_str&#125;&quot;)</span><br><span class="line">        print(&quot;&gt;&gt;&gt; 其中 STR 指令:&quot;)</span><br><span class="line">    for addr, inst in str_insts:</span><br><span class="line">        print(f&quot;    0x&#123;addr:x&#125;: &#123;inst.mnemonic&#125; &#123;inst.op_str&#125;&quot;)</span><br><span class="line"></span><br><span class="line">        # 构造新的指令序列</span><br><span class="line">        new_inst_list = []</span><br><span class="line">    # (1) 添加所有 STR 指令（以其原有汇编文本为准）</span><br><span class="line">    for _, inst in str_insts:</span><br><span class="line">        asm_line = f&quot;&#123;inst.mnemonic&#125; &#123;inst.op_str&#125;&quot;</span><br><span class="line">        new_inst_list.append(asm_line)</span><br><span class="line"></span><br><span class="line">        # (2) 添加两条跳转指令（分支指令），这里假定 self.br_value 存储了两个跳转目标</span><br><span class="line">        # 构造分支指令文本（注意汇编语法，根据实际需要可能调整条件代码）</span><br><span class="line"></span><br><span class="line">        b_inst1 = &quot;b.ne #&quot; + hex(self.br_value[0] - self.csel_addr_temp - len(str_insts)*4)</span><br><span class="line">    b_inst2 = &quot;b #&quot; + hex(self.br_value[1] - self.csel_addr_temp - len(str_insts)*4 - 4)</span><br><span class="line">    for i in range(2):</span><br><span class="line">        print(f&quot;    0x&#123;self.inst_br_addr_temp + i * 4:x&#125;: &#123;b_inst1 if i == 0 else b_inst2&#125;&quot;)</span><br><span class="line">        new_inst_list.append(b_inst1)</span><br><span class="line">    new_inst_list.append(b_inst2)</span><br><span class="line"></span><br><span class="line">    # 使用 Keystone 汇编生成机器码，并计算补丁区域大小</span><br><span class="line">    patch_bytes = b&quot;&quot;</span><br><span class="line">    for asm_line in new_inst_list:</span><br><span class="line">        try:</span><br><span class="line">            encoding, _ = self.ks.asm(asm_line)</span><br><span class="line">            patch_bytes += bytes(encoding)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(f&quot;组装指令失败 &#123;asm_line&#125;: &#123;e&#125;&quot;)</span><br><span class="line"></span><br><span class="line">        # 计算目标区域可用字节数</span><br><span class="line">        region_size = self.inst_br_addr_temp - self.csel_addr_temp</span><br><span class="line">    current_size = len(patch_bytes)</span><br><span class="line">    print(f&quot;累计补丁字节长度: &#123;current_size&#125;, 目标区域大小: &#123;region_size&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    # (3) 如果不足，填充 NOP 指令（ARM64 的 nop 固定4字节）</span><br><span class="line">    if current_size &lt; region_size:</span><br><span class="line">        remaining = region_size - current_size</span><br><span class="line">        nop_count = remaining // 4  # 每个 nop 占4字节</span><br><span class="line">        for _ in range(nop_count):</span><br><span class="line">            try:</span><br><span class="line">                encoding, _ = self.ks.asm(&quot;nop&quot;)</span><br><span class="line">                patch_bytes += bytes(encoding)</span><br><span class="line">            except Exception as e:</span><br><span class="line">                print(f&quot;组装 nop 失败: &#123;e&#125;&quot;)</span><br><span class="line">        # 如果超过目标区域，根据需要截断（不要溢出）</span><br><span class="line">        if len(patch_bytes) &gt; region_size:</span><br><span class="line">            patch_bytes = patch_bytes[:region_size]</span><br><span class="line"></span><br><span class="line">    print(&quot;&gt;&gt;&gt; 重新组装后的补丁字节:&quot;)</span><br><span class="line">    print(patch_bytes.hex())</span><br><span class="line"></span><br><span class="line">    # 将生成的补丁字节写入内存（写回到原区域起始处）</span><br><span class="line">        self.patch_code(addr_start, patch_bytes)</span><br><span class="line">        </span><br><span class="line">        print(&quot;&gt;&gt;&gt; 重写区域内指令:&quot;)</span><br><span class="line">        for addr in range(addr_start, self.inst_br_addr_temp, 4):</span><br><span class="line">            try:</span><br><span class="line">                code = self.mu.mem_read(addr, 4)</span><br><span class="line">            except UcError:</span><br><span class="line">                continue</span><br><span class="line">            for inst in self.cs.disasm(code, addr):</span><br><span class="line">                print(f&quot;    0x&#123;addr:x&#125;: &#123;inst.mnemonic&#125; &#123;inst.op_str&#125;&quot;)</span><br></pre></td></tr></table></figure>

<p>至此，我们完成了所有的工作。再加上亿点小小的细节，添加一下注释和批量优化，就是完整的实现代码</p>
<h2 id="Final：完整实现代码"><a href="#Final：完整实现代码" class="headerlink" title="Final：完整实现代码"></a>Final：完整实现代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br></pre></td><td class="code"><pre><span class="line">import lief</span><br><span class="line">from unicorn import Uc, UcError, UC_ARCH_ARM64, UC_MODE_ARM, UC_HOOK_CODE</span><br><span class="line">from unicorn.arm64_const import *</span><br><span class="line">from capstone import Cs, CS_ARCH_ARM64, CS_MODE_ARM</span><br><span class="line">from keystone import Ks, KS_ARCH_ARM64, KS_MODE_LITTLE_ENDIAN</span><br><span class="line">from pwn import u32</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Arm64ELFSimulator:</span><br><span class="line">    # Configuration constants</span><br><span class="line">    STACK_ADDR = 0x100000</span><br><span class="line">    STACK_SIZE = 1024 * 1024</span><br><span class="line">    PAGE_SIZE = 0x1000# Must be a divisor of the mapped sizes</span><br><span class="line">    BASE_ADDR = 0x0</span><br><span class="line">    ENTRY_POINT = 0x0</span><br><span class="line">    END_POINT = 0x0</span><br><span class="line">    </span><br><span class="line">    # Mapping of register names to Unicorn constants</span><br><span class="line">    regs_dic = &#123;</span><br><span class="line">        &quot;x0&quot;: UC_ARM64_REG_X0, &quot;x1&quot;: UC_ARM64_REG_X1, &quot;x2&quot;: UC_ARM64_REG_X2, &quot;x3&quot;: UC_ARM64_REG_X3,</span><br><span class="line">        &quot;x4&quot;: UC_ARM64_REG_X4, &quot;x5&quot;: UC_ARM64_REG_X5, &quot;x6&quot;: UC_ARM64_REG_X6, &quot;x7&quot;: UC_ARM64_REG_X7,</span><br><span class="line">        &quot;x8&quot;: UC_ARM64_REG_X8, &quot;x9&quot;: UC_ARM64_REG_X9, &quot;x10&quot;: UC_ARM64_REG_X10, &quot;x11&quot;: UC_ARM64_REG_X11,</span><br><span class="line">        &quot;x12&quot;: UC_ARM64_REG_X12, &quot;x13&quot;: UC_ARM64_REG_X13, &quot;x14&quot;: UC_ARM64_REG_X14, &quot;x15&quot;: UC_ARM64_REG_X15,</span><br><span class="line">        &quot;x16&quot;: UC_ARM64_REG_X16, &quot;x17&quot;: UC_ARM64_REG_X17, &quot;x18&quot;: UC_ARM64_REG_X18, &quot;x19&quot;: UC_ARM64_REG_X19,</span><br><span class="line">        &quot;x20&quot;: UC_ARM64_REG_X20, &quot;x21&quot;: UC_ARM64_REG_X21, &quot;x22&quot;: UC_ARM64_REG_X22, &quot;x23&quot;: UC_ARM64_REG_X23,</span><br><span class="line">        &quot;x24&quot;: UC_ARM64_REG_X24, &quot;x25&quot;: UC_ARM64_REG_X25, &quot;x26&quot;: UC_ARM64_REG_X26, &quot;x27&quot;: UC_ARM64_REG_X27,</span><br><span class="line">        &quot;x28&quot;: UC_ARM64_REG_X28, &quot;x29&quot;: UC_ARM64_REG_X29, &quot;x30&quot;: UC_ARM64_REG_X30,</span><br><span class="line">        &quot;sp&quot;: UC_ARM64_REG_SP, &quot;pc&quot;: UC_ARM64_REG_PC</span><br><span class="line">    &#125;</span><br><span class="line">    reg_list = list(regs_dic.values())</span><br><span class="line">    </span><br><span class="line">    def __init__(self, binary_path: str):</span><br><span class="line">        # Initialize Unicorn, Capstone, Keystone</span><br><span class="line">        self.mu = Uc(UC_ARCH_ARM64, UC_MODE_ARM)</span><br><span class="line">        try:</span><br><span class="line">            self.mu.mem_map(self.STACK_ADDR, self.STACK_SIZE)</span><br><span class="line">        except UcError as e:</span><br><span class="line">            print(f&quot;映射栈空间失败: &#123;e&#125;&quot;)</span><br><span class="line">        self.mu.reg_write(UC_ARM64_REG_SP, self.STACK_ADDR + self.STACK_SIZE - 100)</span><br><span class="line">        self.binary_path = binary_path</span><br><span class="line"></span><br><span class="line">        self.cs = Cs(CS_ARCH_ARM64, CS_MODE_ARM)</span><br><span class="line">        self.ks = Ks(KS_ARCH_ARM64, KS_MODE_LITTLE_ENDIAN)</span><br><span class="line"></span><br><span class="line">        # Simulation state</span><br><span class="line">        self.hit_inst = []</span><br><span class="line">        self.csel_handled = False</span><br><span class="line">        self.csel_handled = []</span><br><span class="line">        self.err_addr = []</span><br><span class="line"></span><br><span class="line">        # Load ELF sections and record .text section for later analysis</span><br><span class="line">        self.text_section = None</span><br><span class="line">        self.load_elf_sections()</span><br><span class="line"></span><br><span class="line">        # 初始化预置寄存器及临时变量</span><br><span class="line">        self.mu.reg_write(UC_ARM64_REG_X9, 0x7B6C5B9A)</span><br><span class="line">        self.inst_mov_addr_temp = 0</span><br><span class="line">        self.inst_br_addr_temp = 0</span><br><span class="line">        self.br_reg = 0</span><br><span class="line">        self.csel_addr_temp = 0</span><br><span class="line">        self.csel_args = (0,0,0)</span><br><span class="line">        self.br_value = (0,0)</span><br><span class="line">        self.err_flag = False</span><br><span class="line"></span><br><span class="line">    def load_elf_sections(self) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        利用 LIEF 解析 ELF 文件，将各 section 映射到 Unicorn 内存中。</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        binary = lief.parse(self.binary_path)</span><br><span class="line">        mapped = &#123;&#125;  # 已映射区域字典</span><br><span class="line"></span><br><span class="line">        for section in binary.sections:</span><br><span class="line">            vaddr = section.virtual_address</span><br><span class="line">            mem_size = section.size</span><br><span class="line">            if mem_size == 0 or vaddr == 0:</span><br><span class="line">                continue</span><br><span class="line">            if section.name == &quot;.text&quot;:</span><br><span class="line">                self.text_section = section</span><br><span class="line">            start_addr = (vaddr // self.PAGE_SIZE) * self.PAGE_SIZE</span><br><span class="line">            end_addr = ((vaddr + mem_size + self.PAGE_SIZE - 1) // self.PAGE_SIZE) * self.PAGE_SIZE</span><br><span class="line">            map_size = end_addr - start_addr</span><br><span class="line"></span><br><span class="line">            if start_addr not in mapped:</span><br><span class="line">                try:</span><br><span class="line">                    self.mu.mem_map(start_addr, map_size)</span><br><span class="line">                    mapped[start_addr] = map_size</span><br><span class="line">                except UcError as e:</span><br><span class="line">                    print(f&quot;映射地址&#123;section.name&#125; 0x&#123;start_addr:x&#125;（大小 0x&#123;map_size:x&#125;）失败: &#123;e&#125;&quot;)</span><br><span class="line">                    continue</span><br><span class="line"></span><br><span class="line">            if section.content:</span><br><span class="line">                data = bytes(section.content)</span><br><span class="line">                offset = vaddr - start_addr</span><br><span class="line">                try:</span><br><span class="line">                    self.mu.mem_write(start_addr + offset, data)</span><br><span class="line">                except UcError as e:</span><br><span class="line">                    print(f&quot;写入数据到地址 0x&#123;start_addr+offset:x&#125; 失败: &#123;e&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    def patch_elf_sections(self, output_file: str) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        从 Unicorn 内存中提取所有映射成功的段内容，然后将这些数据</span><br><span class="line">        patch 回 ELF 文件，并写入到 output_file 中。</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 通过 LIEF 重新解析原始 ELF 文件</span><br><span class="line">        elf = lief.parse(self.binary_path)</span><br><span class="line">        </span><br><span class="line">        for section in elf.sections:</span><br><span class="line">            if section.name == &quot;.text&quot; or section.name == &quot;.initarray&quot; or section.name == &quot;.finiarray&quot;:</span><br><span class="line">                </span><br><span class="line">                vaddr = section.virtual_address</span><br><span class="line">                mem_size = section.size</span><br><span class="line">                if mem_size == 0 or vaddr == 0:</span><br><span class="line">                    continue</span><br><span class="line">                # 根据 PAGE_SIZE 计算映射的起始地址和实际偏移量</span><br><span class="line">                start_addr = (vaddr // self.PAGE_SIZE) * self.PAGE_SIZE</span><br><span class="line">                offset = vaddr - start_addr</span><br><span class="line">                try:</span><br><span class="line">                    # 从 Unicorn 内存中读取 section 内容，读取大小为 section.size</span><br><span class="line">                    new_content = self.mu.mem_read(start_addr + offset, mem_size)</span><br><span class="line">                    # LIEF 要求 section.content 为列表形式</span><br><span class="line">                    section.content = list(new_content)</span><br><span class="line">                    print(f&quot;Section &#123;section.name&#125; 更新成功, vaddr: 0x&#123;vaddr:x&#125;, size: &#123;mem_size&#125;&quot;)</span><br><span class="line">                except UcError as e:</span><br><span class="line">                    print(f&quot;读取段 &#123;section.name&#125; 内存失败: &#123;e&#125;&quot;)</span><br><span class="line">            else :</span><br><span class="line">                continue</span><br><span class="line"></span><br><span class="line">        try:</span><br><span class="line">            elf.write(output_file)</span><br><span class="line">            print(f&quot;已将修补后的 ELF 写入到: &#123;output_file&#125;&quot;)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(f&quot;写入补丁 ELF 失败: &#123;e&#125;&quot;)</span><br><span class="line">    </span><br><span class="line">    def find_reg_jmp_addr(self) -&gt; list:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        遍历 .text 段寻找寄存器间接跳转地址，返回 tup( mov_addr, br_addr, reg) 列表。</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        reg_jmp_addr = []</span><br><span class="line">        addr = self.text_section.virtual_address</span><br><span class="line">        while addr &lt; self.text_section.virtual_address + self.text_section.size:</span><br><span class="line">            mov_addr = self.find_mov(addr)</span><br><span class="line">            if mov_addr:</span><br><span class="line">                br_addr, reg = self.find_br(mov_addr)</span><br><span class="line">                if br_addr:</span><br><span class="line">                    reg_jmp_addr.append((mov_addr, br_addr, reg))</span><br><span class="line">                    addr = br_addr</span><br><span class="line">            addr += 4</span><br><span class="line">        return reg_jmp_addr</span><br><span class="line"></span><br><span class="line">    def find_mov(self, addr: int) -&gt; int:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        搜索连续两条带立即数的 mov 指令，</span><br><span class="line">        返回目标 mov 指令的地址，未找到则返回 0。</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        try:</span><br><span class="line">            code = self.mu.mem_read(addr, 4)</span><br><span class="line">        except UcError:</span><br><span class="line">            print(f&quot;&gt;&gt;&gt; read error at find_mov: &#123;hex(addr)&#125;&quot;)</span><br><span class="line">            return 0</span><br><span class="line"></span><br><span class="line">        for inst in self.cs.disasm(code, addr):</span><br><span class="line">            if inst.mnemonic == &quot;mov&quot; and &#x27;#&#x27; in inst.op_str:</span><br><span class="line">                addr += 4</span><br><span class="line">                try:</span><br><span class="line">                    code2 = self.mu.mem_read(addr, 4)</span><br><span class="line">                except UcError:</span><br><span class="line">                    print(f&quot;&gt;&gt;&gt; read error at find_mov: &#123;hex(addr)&#125;&quot;)</span><br><span class="line">                    continue</span><br><span class="line">                for inst_b in self.cs.disasm(code2, addr):</span><br><span class="line">                    if inst_b.mnemonic == &quot;mov&quot; and &#x27;#&#x27; in inst_b.op_str:</span><br><span class="line">                        return addr</span><br><span class="line">        return 0</span><br><span class="line"></span><br><span class="line">    def find_br(self, addr: int) -&gt; tuple:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        向后搜索 &#x27;br&#x27; 指令，返回 (addr, operand) 元组，</span><br><span class="line">        未找到时返回 (0, 0)。</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        for _ in range(1, 100):</span><br><span class="line">            try:</span><br><span class="line">                code = self.mu.mem_read(addr, 4)</span><br><span class="line">            except UcError:</span><br><span class="line">                print(f&quot;&gt;&gt;&gt; read error at find_br: &#123;hex(addr)&#125;&quot;)</span><br><span class="line">                addr += 4</span><br><span class="line">                continue</span><br><span class="line">            for inst in self.cs.disasm(code, addr):</span><br><span class="line">                if inst.mnemonic == &quot;br&quot;:</span><br><span class="line">                    return addr, inst.op_str</span><br><span class="line">            addr += 4</span><br><span class="line">        print(f&quot;&gt;&gt;&gt; find_br 未找到, addr: &#123;hex(addr - 400)&#125;&quot;)</span><br><span class="line">        return 0, 0</span><br><span class="line"></span><br><span class="line">    def print_regs(self) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot; 打印当前所有寄存器的值 &quot;&quot;&quot;</span><br><span class="line">        print(&quot;&gt;&gt;&gt; Registers:&quot;)</span><br><span class="line">        for name, reg in self.regs_dic.items():</span><br><span class="line">            print(f&quot;    &#123;name&#125; = 0x&#123;self.mu.reg_read(reg):x&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    def print_stack_sp(self) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot; 打印当前栈区域的部分内容 &quot;&quot;&quot;</span><br><span class="line">        sp = self.mu.reg_read(UC_ARM64_REG_SP)</span><br><span class="line">        print(&quot;&gt;&gt;&gt; Stack:&quot;)</span><br><span class="line">        for i in range(0, 32, 4):</span><br><span class="line">            try:</span><br><span class="line">                data = self.mu.mem_read(sp + i, 4)</span><br><span class="line">                print(f&quot;    0x&#123;sp + i:x&#125;: &#123;u32(data):x&#125;&quot;)</span><br><span class="line">            except UcError:</span><br><span class="line">                print(f&quot;    0x&#123;sp + i:x&#125;: ???&quot;)</span><br><span class="line">        print(&quot;&quot;)</span><br><span class="line"></span><br><span class="line">    def save_state(self) -&gt; dict:</span><br><span class="line">        &quot;&quot;&quot; 保存当前寄存器状态 &quot;&quot;&quot;</span><br><span class="line">        return &#123;reg: self.mu.reg_read(reg) for reg in self.reg_list&#125;</span><br><span class="line"></span><br><span class="line">    def restore_state(self, state: dict) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot; 恢复寄存器状态 &quot;&quot;&quot;</span><br><span class="line">        for reg, value in state.items():</span><br><span class="line">            self.mu.reg_write(reg, value)</span><br><span class="line"></span><br><span class="line">    def clear_state(self) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot; 清空所有寄存器，并重置 csel 标志 &quot;&quot;&quot;</span><br><span class="line">        self.csel_handled = False</span><br><span class="line">        for reg in self.reg_list:</span><br><span class="line">            self.mu.reg_write(reg, 0)</span><br><span class="line"></span><br><span class="line">    def hit_hook(self, mu: Uc, addr: int, size: int, user_data) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        代码 hook，用于捕获并存储 hit 指令（通过向上追踪含 SP 且 ldr 指令）。</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        </span><br><span class="line">        try:</span><br><span class="line">            code = mu.mem_read(addr, size)</span><br><span class="line">        except UcError:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        for inst in self.cs.disasm(code, addr):</span><br><span class="line">            # print(f&quot;hit hook : &gt;&gt;&gt; &#123;hex(addr)&#125; &#123;inst.mnemonic&#125; &#123;inst.op_str&#125;&quot;)</span><br><span class="line">            if inst.mnemonic.lower() == &quot;br&quot;:</span><br><span class="line">                mu.emu_stop()</span><br><span class="line">                break</span><br><span class="line">            if inst.mnemonic.lower() == &quot;stur&quot; or inst.mnemonic.lower() == &quot;ldur&quot;:</span><br><span class="line">                self.mu.reg_write(UC_ARM64_REG_PC, addr + size)</span><br><span class="line">                # print(f&quot;&gt;&gt;&gt; stur or ldur detected, skip&quot;)</span><br><span class="line">                return</span><br><span class="line">            if &quot;sp&quot; in inst.op_str and &quot;ldr&quot; in inst.mnemonic:</span><br><span class="line">                # print(f&quot;attached ldr sp instruction: &#123;inst.mnemonic&#125; &#123;inst.op_str&#125;&quot;)</span><br><span class="line">                parts = inst.op_str.split(&quot;, [&quot;)</span><br><span class="line">                target = parts[0] if &quot;sp&quot; in parts[0] else parts[1]</span><br><span class="line">                target_state = False</span><br><span class="line">                target2 = &quot;&quot;</span><br><span class="line">                curr_addr = addr</span><br><span class="line">                for _ in range(1, 200):</span><br><span class="line">                    curr_addr -= inst.size</span><br><span class="line">                    try:</span><br><span class="line">                        code_b = mu.mem_read(curr_addr, 4)</span><br><span class="line">                    except UcError:</span><br><span class="line">                        continue</span><br><span class="line">                    for inst_b in self.cs.disasm(code_b, curr_addr):</span><br><span class="line">                        if target in inst_b.op_str and &quot;ldr&quot; not in inst_b.mnemonic and not target_state:</span><br><span class="line">                            # print(f&quot;hit instruction: &#123;inst_b.mnemonic&#125; &#123;inst_b.op_str&#125;&quot;)</span><br><span class="line">                            target_state = True</span><br><span class="line">                            self.hit_inst.append(inst_b)</span><br><span class="line">                            parts_b = inst_b.op_str.split(&quot;, &quot;)</span><br><span class="line">                            target2 = parts_b[0] if target not in parts_b[0] else parts_b[1]</span><br><span class="line">                            break</span><br><span class="line">                        if target_state and target2 in inst_b.op_str and &quot;mov&quot; in inst_b.mnemonic and &#x27;#0x&#x27; in inst_b.op_str:</span><br><span class="line">                            self.hit_inst.append(inst_b)</span><br><span class="line">                        if target_state and target2 in inst_b.op_str and &#x27;adr&#x27; in inst_b.mnemonic:</span><br><span class="line">                            # print(f&quot;hit instruction: &#123;inst_b.mnemonic&#125; &#123;inst_b.op_str&#125;&quot;)</span><br><span class="line">                            if &quot;adrp&quot; in inst_b.mnemonic:</span><br><span class="line">                                try:</span><br><span class="line">                                    next_code = mu.mem_read(curr_addr + inst_b.size, 4)</span><br><span class="line">                                except UcError:</span><br><span class="line">                                    continue</span><br><span class="line">                                for inst_el in self.cs.disasm(next_code, curr_addr + inst_b.size):</span><br><span class="line">                                    if &quot;add&quot; in inst_el.mnemonic:</span><br><span class="line">                                        self.hit_inst.append(inst_el)</span><br><span class="line">                                        self.hit_inst.append(inst_b)</span><br><span class="line">                            else:</span><br><span class="line">                                self.hit_inst.append(inst_b)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    def branch_hook(self, mu: Uc, addr: int, size: int, user_data) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        当执行到 BR 指令时停止模拟</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        try:</span><br><span class="line">            code = mu.mem_read(addr, size)</span><br><span class="line">        except UcError:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        for inst in self.cs.disasm(code, addr):</span><br><span class="line">            if inst.mnemonic.lower() == &quot;br&quot;:</span><br><span class="line">                # print(f&quot;&gt;&gt;&gt; BR 指令在 0x&#123;addr:x&#125; 被触发，停止模拟&quot;)</span><br><span class="line">                mu.emu_stop()</span><br><span class="line">                break</span><br><span class="line">    </span><br><span class="line">    def get_hit_inst(self, addr: int) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        从指定地址向后模拟收集 hit 指令</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # print(f&quot;&gt;&gt;&gt; Getting hit instructions from 0x&#123;addr:x&#125; to 0x&#123;self.inst_br_addr_temp:x&#125;&quot;)</span><br><span class="line">        bh_id = self.mu.hook_add(UC_HOOK_CODE, self.hit_hook)</span><br><span class="line">        self.mu.hook_del(self.hook_code_id)</span><br><span class="line">        # 搜寻前面的有没有立即数存储指令</span><br><span class="line">        for i in range(1, 50):</span><br><span class="line">            try:</span><br><span class="line">                code = self.mu.mem_read(addr - i * 4, 4)</span><br><span class="line">            except UcError:</span><br><span class="line">                continue</span><br><span class="line">            for inst in self.cs.disasm(code, addr - i * 4):</span><br><span class="line">                # print(f&quot;get_hit_inst : &gt;&gt;&gt; &#123;hex(addr - i * 4)&#125; &#123;inst.mnemonic&#125; &#123;inst.op_str&#125;&quot;)</span><br><span class="line">                if (&quot;mov&quot; in inst.mnemonic or &quot;ldr&quot; in inst.mnemonic ) and &#x27;#&#x27; in inst.op_str:</span><br><span class="line">                    self.hit_inst.append(inst)</span><br><span class="line">        </span><br><span class="line">        try:</span><br><span class="line">            self.mu.emu_start(addr - 4, self.inst_br_addr_temp)</span><br><span class="line">        except UcError as e:</span><br><span class="line">            print(&quot;模拟过程中出现错误:&quot;, e)</span><br><span class="line">            self.err_flag = True</span><br><span class="line">            self.err_addr.append((self.inst_mov_addr_temp, self.inst_br_addr_temp,&quot;error at get_hit_inst:&quot;, e))</span><br><span class="line">        self.mu.hook_del(bh_id)</span><br><span class="line">        self.hook_code_id = self.mu.hook_add(UC_HOOK_CODE, self.hook_code)</span><br><span class="line">        # print(&quot;\n&gt;&gt;&gt; Hit instructions:&quot;)</span><br><span class="line">        # for inst in self.hit_inst:</span><br><span class="line">        #     print(f&quot;    0x&#123;inst.address:x&#125;: &#123;inst.mnemonic&#125; &#123;inst.op_str&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    def run_hit_inst(self) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        只模拟 hit 指令（hit_inst 列表中的指令）。</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # print(&quot;&gt;&gt;&gt; Running hit instructions&quot;)</span><br><span class="line">        original_pc = self.mu.reg_read(UC_ARM64_REG_PC)</span><br><span class="line">        for inst in reversed(self.hit_inst):</span><br><span class="line">            </span><br><span class="line">            try:</span><br><span class="line">                self.mu.emu_start(inst.address, inst.address + inst.size)</span><br><span class="line">            except UcError as e:</span><br><span class="line">                print(&quot;run_hit_inst 模拟出现错误:&quot;, e)</span><br><span class="line">                self.err_flag = True</span><br><span class="line">                self.err_addr.append((self.inst_mov_addr_temp, self.inst_br_addr_temp, &quot;error at run_hit_inst:&quot;, e))</span><br><span class="line">        self.mu.reg_write(UC_ARM64_REG_PC, original_pc)</span><br><span class="line"></span><br><span class="line">    def patch_code(self, addr: int, patch_bytes: bytes) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        打补丁，将代码修改为 patch_bytes</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.mu.mem_write(addr, patch_bytes)</span><br><span class="line">        # print(f&quot;&gt;&gt;&gt; 已将地址 0x&#123;addr:x&#125; patch 为 &#123;patch_bytes&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    def hook_code(self, mu: Uc, address: int, size: int, user_data) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        检测 CSEL 指令，进行向后分析并实现分支变种测试</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        try:</span><br><span class="line">            code = mu.mem_read(address, size)</span><br><span class="line">        except UcError:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        for inst in self.cs.disasm(code, address):</span><br><span class="line">            # print(f&quot;&gt;&gt;&gt; addr:&#123;hex(address)&#125;  &#123;inst.mnemonic&#125; &#123;inst.op_str&#125;&quot;)</span><br><span class="line">            if inst.mnemonic.lower() == &quot;stur&quot; or inst.mnemonic.lower() == &quot;ldur&quot;:</span><br><span class="line">                self.mu.reg_write(UC_ARM64_REG_PC, address + size)</span><br><span class="line">                # print(f&quot;&gt;&gt;&gt; stur or ldur detected, skip&quot;)</span><br><span class="line">                return</span><br><span class="line">            if inst.mnemonic.lower() == &quot;csel&quot; and not self.csel_handled:</span><br><span class="line">                # print(&quot;&gt;&gt;&gt; csel detected&quot;)</span><br><span class="line">                self.csel_handled = True</span><br><span class="line">                self.csel_addr_temp = address</span><br><span class="line">                saved_state = self.save_state()  # 保存当前状态</span><br><span class="line">                </span><br><span class="line">                # 使用 mov_addr_temp 作为先前的 mov 指令地址</span><br><span class="line">                # print(&quot;&gt;&gt;&gt; start get hit inst\n&quot;)</span><br><span class="line">                # self.print_regs()</span><br><span class="line">                mov_addr = self.inst_mov_addr_temp</span><br><span class="line">                self.hit_inst = []  # 重置 hit 指令列表</span><br><span class="line">                self.get_hit_inst(mov_addr)</span><br><span class="line">                self.run_hit_inst()</span><br><span class="line">                self.restore_state(saved_state)</span><br><span class="line"></span><br><span class="line">                operands = inst.op_str.split(&quot;, &quot;)</span><br><span class="line">                self.csel_args = (operands[0],operands[1], operands[2])</span><br><span class="line">                mov_inst1 = f&quot;mov &#123;operands[0]&#125;, &#123;operands[1]&#125;;&quot;</span><br><span class="line">                mov_inst2 = f&quot;mov &#123;operands[0]&#125;, &#123;operands[2]&#125;;&quot;</span><br><span class="line">                asm_mov_branch1, _ = self.ks.asm(mov_inst1)</span><br><span class="line">                asm_mov_branch2, _ = self.ks.asm(mov_inst2)</span><br><span class="line"></span><br><span class="line">                def run_branch_test(patch_bytes: list, branch_label: str) -&gt; dict:</span><br><span class="line">                    self.mu.mem_write(self.csel_addr_temp, bytes(patch_bytes))</span><br><span class="line">                    # print(f&quot;&gt;&gt;&gt; 已将 csel 指令 patch 为 &#123;branch_label&#125;，开始执行至遇到 BR 指令&quot;)</span><br><span class="line">                    bh_id = self.mu.hook_add(UC_HOOK_CODE, self.branch_hook)</span><br><span class="line">                    try:</span><br><span class="line">                        self.mu.emu_start(self.inst_mov_addr_temp - 4, self.inst_br_addr_temp)</span><br><span class="line">                    except UcError as e:</span><br><span class="line">                        print(&quot;run_branch_test 模拟错误:&quot;, e)</span><br><span class="line">                        self.err_flag = True</span><br><span class="line">                        self.err_addr.append((self.inst_mov_addr_temp, self.inst_br_addr_temp,&quot;error at run_branch_test:&quot;, e))</span><br><span class="line">                    self.mu.hook_del(bh_id)</span><br><span class="line">                    return self.save_state()</span><br><span class="line"></span><br><span class="line">                # print(&quot;&gt;&gt;&gt; Executing first branch variation&quot;)</span><br><span class="line">                self.run_hit_inst()</span><br><span class="line">                saved_state = self.save_state()</span><br><span class="line">                state_branch1 = run_branch_test(asm_mov_branch1, mov_inst1)</span><br><span class="line">                self.restore_state(saved_state)</span><br><span class="line">                self.run_hit_inst()</span><br><span class="line">                # print(&quot;&gt;&gt;&gt; Executing second branch variation&quot;)</span><br><span class="line">                state_branch2 = run_branch_test(asm_mov_branch2, mov_inst2)</span><br><span class="line"></span><br><span class="line">                print(&quot;&gt;&gt;&gt; Final state:&quot;)</span><br><span class="line">                </span><br><span class="line">                br_value1 = state_branch1.get(self.regs_dic[self.br_reg], 0)</span><br><span class="line">                br_value2 = state_branch2.get(self.regs_dic[self.br_reg], 0)</span><br><span class="line">                if br_value1 + br_value2 &gt; 0x10000:</span><br><span class="line">                    print(f&quot;maybe br addr error: &#123;hex(br_value1)&#125; , &#123;hex(br_value2)&#125;&quot;)</span><br><span class="line">                    # self.print_regs()</span><br><span class="line">                    self.err_flag = True</span><br><span class="line">                    self.err_addr.append((self.inst_mov_addr_temp, self.inst_br_addr_temp,&quot;error at run_branch_test:&quot;,0))</span><br><span class="line">                    return</span><br><span class="line">                else:    </span><br><span class="line">                    print(f&quot;    1: &#123;hex(br_value1)&#125;&quot;)</span><br><span class="line">                    print(f&quot;    2: &#123;hex(br_value2)&#125;&quot;)</span><br><span class="line">                    self.br_value = (br_value1, br_value2)</span><br><span class="line">                    self.mu.emu_stop()</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    def emulate_single_addr(self,mov_addr, br_addr, br_reg) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        模拟执行单组地址</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        </span><br><span class="line">        self.inst_mov_addr_temp = mov_addr</span><br><span class="line">        self.inst_br_addr_temp = br_addr</span><br><span class="line">        self.br_reg = br_reg</span><br><span class="line">        # print(f&quot;\n&gt;&gt;&gt; Processing indirect jump: mov_addr=0x&#123;mov_addr:x&#125;, br_addr=0x&#123;br_addr:x&#125;, br_reg=&#123;br_reg&#125;&quot;)</span><br><span class="line">        try:</span><br><span class="line">            self.clear_state()</span><br><span class="line">            self.hook_code_id = self.mu.hook_add(UC_HOOK_CODE, self.hook_code)</span><br><span class="line">            self.mu.emu_start(self.BASE_ADDR + mov_addr, br_addr)</span><br><span class="line">            self.mu.hook_del(self.hook_code_id)</span><br><span class="line">        except UcError as e:</span><br><span class="line">            print(&quot;run() 执行错误:&quot;, e)</span><br><span class="line">            self.err_flag = True</span><br><span class="line">            self.err_addr.append((mov_addr, br_addr, &quot;error at run():&quot;, e))</span><br><span class="line"></span><br><span class="line">    # python</span><br><span class="line">    def patch_br(self) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        扫描 self.csel_addr_temp 到 self.inst_br_addr_temp 区间内的所有指令，</span><br><span class="line">        记录所有 STR 指令，将所有 STR 指令上移，其余指令下移，</span><br><span class="line">        重新构造新的指令序列：首先放置所有 STR 指令，</span><br><span class="line">        然后是两条分支指令，</span><br><span class="line">        剩余空间填充 NOP 指令（注意：不能超过原区域大小）。</span><br><span class="line">        最后将组装好的字节补丁写入内存。</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        </span><br><span class="line">        all_insts = []   # 保存区间内所有(地址, 指令)元组</span><br><span class="line">        str_insts = []   # 保存STR类型指令</span><br><span class="line"></span><br><span class="line">        addr_start = self.csel_addr_temp </span><br><span class="line">        for addr in range(addr_start, self.inst_br_addr_temp, 4):</span><br><span class="line">            try:</span><br><span class="line">                code = self.mu.mem_read(addr, 4)</span><br><span class="line">            except UcError:</span><br><span class="line">                continue</span><br><span class="line">            for inst in self.cs.disasm(code, addr):</span><br><span class="line">                all_insts.append((addr, inst))</span><br><span class="line">                if &quot;str&quot; in inst.mnemonic.lower():</span><br><span class="line">                    str_insts.append((addr, inst))</span><br><span class="line">        </span><br><span class="line">        # print(&quot;&gt;&gt;&gt; 扫描到的所有指令:&quot;)</span><br><span class="line">        # for addr, inst in all_insts:</span><br><span class="line">        #     print(f&quot;    0x&#123;addr:x&#125;: &#123;inst.mnemonic&#125; &#123;inst.op_str&#125;&quot;)</span><br><span class="line">        # print(&quot;&gt;&gt;&gt; 其中 STR 指令:&quot;)</span><br><span class="line">        # for addr, inst in str_insts:</span><br><span class="line">        #     print(f&quot;    0x&#123;addr:x&#125;: &#123;inst.mnemonic&#125; &#123;inst.op_str&#125;&quot;)</span><br><span class="line">        </span><br><span class="line">        # 构造新的指令序列</span><br><span class="line">        new_inst_list = []</span><br><span class="line">        # (1) 添加所有 STR 指令（以其原有汇编文本为准）</span><br><span class="line">        for _, inst in str_insts:</span><br><span class="line">            asm_line = f&quot;&#123;inst.mnemonic&#125; &#123;inst.op_str&#125;&quot;</span><br><span class="line">            new_inst_list.append(asm_line)</span><br><span class="line">        </span><br><span class="line">        # (2) 添加两条跳转指令（分支指令），这里假定 self.br_value 存储了两个跳转目标</span><br><span class="line">        # 构造分支指令文本（注意汇编语法，根据实际需要可能调整条件代码）</span><br><span class="line">        </span><br><span class="line">        b_inst1 = &quot;b.ne #&quot; + hex(self.br_value[0] - self.csel_addr_temp - len(str_insts)*4)</span><br><span class="line">        b_inst2 = &quot;b #&quot; + hex(self.br_value[1] - self.csel_addr_temp - len(str_insts)*4 - 4)</span><br><span class="line">        for i in range(2):</span><br><span class="line">            print(f&quot;    0x&#123;self.inst_br_addr_temp + i * 4:x&#125;: &#123;b_inst1 if i == 0 else b_inst2&#125;&quot;)</span><br><span class="line">        new_inst_list.append(b_inst1)</span><br><span class="line">        new_inst_list.append(b_inst2)</span><br><span class="line">        </span><br><span class="line">        # 使用 Keystone 汇编生成机器码，并计算补丁区域大小</span><br><span class="line">        patch_bytes = b&quot;&quot;</span><br><span class="line">        for asm_line in new_inst_list:</span><br><span class="line">            try:</span><br><span class="line">                encoding, _ = self.ks.asm(asm_line)</span><br><span class="line">                patch_bytes += bytes(encoding)</span><br><span class="line">            except Exception as e:</span><br><span class="line">                print(f&quot;组装指令失败 &#123;asm_line&#125;: &#123;e&#125;&quot;)</span><br><span class="line">        </span><br><span class="line">        # 计算目标区域可用字节数</span><br><span class="line">        region_size = self.inst_br_addr_temp - self.csel_addr_temp</span><br><span class="line">        current_size = len(patch_bytes)</span><br><span class="line">        # print(f&quot;累计patch字节长度: &#123;current_size&#125;, 目标区域大小: &#123;region_size&#125;&quot;)</span><br><span class="line">        </span><br><span class="line">        # (3) 如果不足，填充 NOP 指令（ARM64 的 nop 固定4字节）</span><br><span class="line">        if current_size &lt; region_size:</span><br><span class="line">            remaining = region_size - current_size</span><br><span class="line">            nop_count = remaining // 4  # 每个 nop 占4字节</span><br><span class="line">            for _ in range(nop_count):</span><br><span class="line">                try:</span><br><span class="line">                    encoding, _ = self.ks.asm(&quot;nop&quot;)</span><br><span class="line">                    patch_bytes += bytes(encoding)</span><br><span class="line">                except Exception as e:</span><br><span class="line">                    print(f&quot;组装 nop 失败: &#123;e&#125;&quot;)</span><br><span class="line">        # 如果超过目标区域，根据需要截断（不要溢出）</span><br><span class="line">        if len(patch_bytes) &gt; region_size:</span><br><span class="line">            patch_bytes = patch_bytes[:region_size]</span><br><span class="line">        </span><br><span class="line">        # print(&quot;&gt;&gt;&gt; 重新组装后的补丁字节:&quot;)</span><br><span class="line">        # print(patch_bytes.hex())</span><br><span class="line">        </span><br><span class="line">        # 将生成的补丁字节写入内存（写回到原区域起始处）</span><br><span class="line">        self.patch_code(addr_start, patch_bytes)</span><br><span class="line">        </span><br><span class="line">        # print(&quot;&gt;&gt;&gt; 重写区域内指令:&quot;)</span><br><span class="line">        for addr in range(addr_start, self.inst_br_addr_temp, 4):</span><br><span class="line">            try:</span><br><span class="line">                code = self.mu.mem_read(addr, 4)</span><br><span class="line">            except UcError:</span><br><span class="line">                continue</span><br><span class="line">            # for inst in self.cs.disasm(code, addr):</span><br><span class="line">            #     print(f&quot;    0x&#123;addr:x&#125;: &#123;inst.mnemonic&#125; &#123;inst.op_str&#125;&quot;)</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    def run(self) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        启动模拟执行，先收集间接跳转地址，再逐个模拟</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.reg_jmp_addr = self.find_reg_jmp_addr()</span><br><span class="line">        for addr in self.reg_jmp_addr:</span><br><span class="line">            print(f&quot;indirect jmp addr: 0x&#123;addr[0]:x&#125;, br addr: 0x&#123;addr[1]:x&#125;, br reg: &#123;addr[2]&#125;&quot;)</span><br><span class="line">        print(f&quot;\n&gt;&gt;&gt; 共找到 &#123;len(self.reg_jmp_addr)&#125; 个间接跳转地址&quot;)</span><br><span class="line">        cnt = 0</span><br><span class="line">        for mov_addr, br_addr, br_reg in self.reg_jmp_addr:</span><br><span class="line">            # if br_addr != 0x1638:</span><br><span class="line">            #     continue</span><br><span class="line">            cnt+=1</span><br><span class="line">            # print(f&quot;\n&gt;&gt;&gt; Processing indirect jump &#123;cnt&#125;: mov_addr=0x&#123;mov_addr:x&#125;, br_addr=0x&#123;br_addr:x&#125;, br_reg=&#123;br_reg&#125;&quot;)</span><br><span class="line">            try:</span><br><span class="line">                self.emulate_single_addr(mov_addr, br_addr, br_reg)</span><br><span class="line">                if self.err_flag:</span><br><span class="line">                    self.err_flag = False</span><br><span class="line">                    continue</span><br><span class="line">                self.patch_br()</span><br><span class="line">            except:</span><br><span class="line">                continue</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        if self.err_addr:</span><br><span class="line">            print(&quot;\n&gt;&gt;&gt; Error addresses:&quot;)</span><br><span class="line">            for addr in self.err_addr:</span><br><span class="line">                print(f&quot;    indirect jmp addr: 0x&#123;addr[0]:x&#125;, br addr: 0x&#123;addr[1]:x&#125; , &#123;addr[2]&#125; , &#123;addr[3]&#125;&quot;)</span><br><span class="line">            </span><br><span class="line">            for addr in self.err_addr:</span><br><span class="line">                print(f&quot;( &#123;addr[0]&#125; , &#123;addr[1]&#125; , \&quot; &#123;addr[2]&#125; \&quot;) ,&quot; , end=&quot;&quot;)</span><br><span class="line">                </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def main() -&gt; None:</span><br><span class="line">    binary_path = r&quot;F:\_reverse_study\_unicorn_study\task1\easy-re&quot;</span><br><span class="line">    simulator = Arm64ELFSimulator(binary_path)</span><br><span class="line">    simulator.run()</span><br><span class="line">    # simulator.run_err_addr(err_addr)</span><br><span class="line">    simulator.patch_elf_sections(binary_path + &quot;_patched&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-282826.htm">https://bbs.kanxue.com/thread-282826.htm</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Luckiers/article/details/128221506">https://blog.csdn.net/Luckiers/article/details/128221506</a><br><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-283706.htm">https://bbs.kanxue.com/thread-283706.htm</a><br><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-280231.htm">https://bbs.kanxue.com/thread-280231.htm</a></p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/Friends/">Friends</a></li>
        
          <li><a href="/Search/">Search</a></li>
        
          <li><a href="/About/">About</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E8%B7%B3%E8%BD%AC%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">寄存器间接跳转的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%84%E7%90%86%E6%80%9D%E8%B7%AF"><span class="toc-number">2.</span> <span class="toc-text">简单的处理思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E4%B8%80%E7%82%B9%E7%9A%84%E8%BF%9B%E9%98%B6%E6%80%9D%E8%B7%AF"><span class="toc-number">3.</span> <span class="toc-text">自动化一点的进阶思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%EF%BC%9AN1CTF-junior-easy-re"><span class="toc-number">3.1.</span> <span class="toc-text">实例：N1CTF junior easy-re</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#step1-%E6%8C%89%E7%85%A7%E4%B8%8D%E5%90%8C%E8%B7%B3%E8%BD%AC%E5%88%86%E6%94%AF%E8%BF%9B%E8%A1%8C%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86"><span class="toc-number">4.</span> <span class="toc-text">step1 按照不同跳转分支进行信息搜集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#step2-%E6%A8%A1%E6%8B%9F%E6%89%A7%E8%A1%8C%EF%BC%8C%E8%8E%B7%E5%8F%96%E6%9C%80%E7%BB%88%E8%B7%B3%E8%BD%AC%E5%80%BC"><span class="toc-number">5.</span> <span class="toc-text">step2 模拟执行，获取最终跳转值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#step3-%E4%BD%BF%E7%94%A8%E4%B8%8A%E4%B8%80%E6%AD%A5%E7%9A%84%E5%80%BC%E8%BF%9B%E8%A1%8CPatch"><span class="toc-number">6.</span> <span class="toc-text">step3 使用上一步的值进行Patch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Final%EF%BC%9A%E5%AE%8C%E6%95%B4%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81"><span class="toc-number">7.</span> <span class="toc-text">Final：完整实现代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number">8.</span> <span class="toc-text">参考链接</span></a></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <!-- <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://lancer0rz.github.io/2025/03/31/%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E8%B7%B3%E8%BD%AC%E6%B7%B7%E6%B7%86%E5%8E%BB%E9%99%A4%E5%AE%9E%E6%88%98/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li> -->
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://lancer0rz.github.io/2025/03/31/%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E8%B7%B3%E8%BD%AC%E6%B7%B7%E6%B7%86%E5%8E%BB%E9%99%A4%E5%AE%9E%E6%88%98/&text=寄存器间接跳转混淆去除实战"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <!-- <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://lancer0rz.github.io/2025/03/31/%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E8%B7%B3%E8%BD%AC%E6%B7%B7%E6%B7%86%E5%8E%BB%E9%99%A4%E5%AE%9E%E6%88%98/&title=寄存器间接跳转混淆去除实战"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li> -->
  <!-- <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://lancer0rz.github.io/2025/03/31/%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E8%B7%B3%E8%BD%AC%E6%B7%B7%E6%B7%86%E5%8E%BB%E9%99%A4%E5%AE%9E%E6%88%98/&is_video=false&description=寄存器间接跳转混淆去除实战"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li> -->
  <li><a class="icon" href="mailto:?subject=寄存器间接跳转混淆去除实战&body=Check out this article: https://lancer0rz.github.io/2025/03/31/%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E8%B7%B3%E8%BD%AC%E6%B7%B7%E6%B7%86%E5%8E%BB%E9%99%A4%E5%AE%9E%E6%88%98/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://lancer0rz.github.io/2025/03/31/%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E8%B7%B3%E8%BD%AC%E6%B7%B7%E6%B7%86%E5%8E%BB%E9%99%A4%E5%AE%9E%E6%88%98/&title=寄存器间接跳转混淆去除实战"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <!-- <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://lancer0rz.github.io/2025/03/31/%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E8%B7%B3%E8%BD%AC%E6%B7%B7%E6%B7%86%E5%8E%BB%E9%99%A4%E5%AE%9E%E6%88%98/&title=寄存器间接跳转混淆去除实战"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li> -->
  <!-- <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://lancer0rz.github.io/2025/03/31/%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E8%B7%B3%E8%BD%AC%E6%B7%B7%E6%B7%86%E5%8E%BB%E9%99%A4%E5%AE%9E%E6%88%98/&title=寄存器间接跳转混淆去除实战"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li> -->
  <!-- <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://lancer0rz.github.io/2025/03/31/%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E8%B7%B3%E8%BD%AC%E6%B7%B7%E6%B7%86%E5%8E%BB%E9%99%A4%E5%AE%9E%E6%88%98/&title=寄存器间接跳转混淆去除实战"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li> -->
  <!-- <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://lancer0rz.github.io/2025/03/31/%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E8%B7%B3%E8%BD%AC%E6%B7%B7%E6%B7%86%E5%8E%BB%E9%99%A4%E5%AE%9E%E6%88%98/&name=寄存器间接跳转混淆去除实战&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li> -->
  <!-- <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://lancer0rz.github.io/2025/03/31/%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E8%B7%B3%E8%BD%AC%E6%B7%B7%E6%B7%86%E5%8E%BB%E9%99%A4%E5%AE%9E%E6%88%98/&t=寄存器间接跳转混淆去除实战"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li> -->
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    <!-- Copyright --> &copy;
    
    
    2018-2026
    l4n
  </div>
  
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/Friends/">Friends</a></li><!--
     --><!--
       --><li><a href="/Search/">Search</a></li><!--
     --><!--
       --><li><a href="/About/">About</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- 51la Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

<!-- image modal -->
<script>
  (function() {
    var contentNode = document.getElementsByClassName('content e-content');
    if (!contentNode || contentNode.length === 0) {
      console.log('no content, exit');
      return;
    }

    var imgsNodes = contentNode[0].getElementsByTagName('img');
    if (!imgsNodes || imgsNodes.length === 0) {
      console.log('no image, exit');
      return;
    }

    var span = document.getElementById('modal_close_btn');
    span.onclick = function() { 
      modal.style.display = "none";
    };

    var modal = document.getElementById('modal');
    var modalImage = document.getElementById('modal_image');
    var captionText = document.getElementById('caption');

    for (var i = imgsNodes.length - 1; i >= 0; i--) {
      let image = imgsNodes[i];
      image.onclick = function() {
        modal.style.display = "block";
        modalImage.src = this.src;
        captionText.innerHTML = this.alt || "文章配图";
      };
    }
  }());
</script>

</body>
</html>
